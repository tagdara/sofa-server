import asyncio
import aiohttp
from aiohttp import web
import concurrent.futures
import logging
import sys
import time
import json
import urllib.request
import collections
import jsonpatch
import copy
import dpath
import datetime
import uuid
import functools
import devices

from hbmqtt.client import MQTTClient, ClientException
from hbmqtt.mqtt.constants import QOS_1, QOS_2


class commandObjects:
    
    commandTypes = {

        "response": {
                "event": {
                    "endpoint": {
                        "scope": {'token': 'Alexa-access-token', 'type': 'BearerToken'}, 
                        "endpointId": 'Master_Bedroom_Regan_2'
                    }, 
                    "header": {
                        "name": "Response",
                        "payloadVersion": "3",
                        "namespace": "Alexa",
                        "messageId": "abc-123-def-456"
                    }, 
                    "payload": {}
                }, 
                "context": {
                    "properties": [
                        {   'timeOfSample': 
                            '2018-05-07T23:43:21.080580Z',
                            'name': 'powerState',
                            'uncertaintyInMilliseconds': 500,
                            'namespace': 'Alexa.PowerController',
                            'value': 'OFF'
                        }
                    ]
                }
        },

        "action": {
                "directive": {
                    "endpoint": {
                        "scope": {"type": "BearerToken"}, 
                        "endpointId": "Master_Bedroom_Regan_1",
                        "cookie": {
                            'extraDetail1': 'Master Bedroom Regan 1'
                        }
                    }, 
                    'header': {
                        'messageId': "abc-123-def-456",
                        'name': 'TurnOff',
                        'payloadVersion': '3',
                        'namespace': 'Alexa.PowerController'
                    }, 
                    'payload': {}
                }
        },
        "reportstate": {
                "directive": {
                    "header": {
                        "messageId": "abc-123-def-456",
                        "correlationToken": "abcdef-123456",
                        "namespace": "Alexa",
                        "name": "ReportState",
                        "payloadVersion": "3"
                    },
                    "endpoint": {
                        "endpointId": "appliance-001",
                        "cookie": {},
                        "scope":{  
                            "type":"BearerToken",
                            "token":"access-token-from-skill"
                        }
                    },
                    "payload": {}
                }
        },
        
        "stateReport": {  
                "context":  {  
                    "properties": [  
                        {  
                            "namespace":"Alexa.ThermostatController",
                            "name":"targetSetpoint",
                            "value": {  
                                "value":25.0,
                                "scale":"CELSIUS"
                            },
                            "timeOfSample":"2017-02-03T16:20:50.52Z",
                            "uncertaintyInMilliseconds":6000
                        },
                        {  
                            "namespace":"Alexa.ThermostatController",
                            "name":"thermostatMode",
                            "value":"HEAT",
                            "timeOfSample":"2017-02-03T16:20:50.52Z",
                            "uncertaintyInMilliseconds":6000
                        }
                    ]
                },
                "event":{  
                    "header":{  
                        "messageId":"abc-123-def-456",
                        "correlationToken":"abcdef-123456",
                        "namespace":"Alexa",
                        "name":"StateReport",
                        "payloadVersion":"3"
                    },
                    "endpoint":{  
                        "endpointId":"appliance-001",
                        "cookie":{}
                    }
                },
                "payload":{}
        }
}

class controllerObjects:
    
    interfaceTypes = {
        
        "BrightnessController": {
            "type": "AlexaInterface",
            "interface": "Alexa.BrightnessController",
            "version": "3",
            "properties": {
                "supported": [
                    {"name": "brightness"}
                ],
                "proactivelyReported": True,
                "retrievable": True
            }
        },

        "ColorController": {
            "type":"AlexaInterface",
            "interface":"Alexa.ColorController",
            "version":"3",
            "properties":{
                "supported":[
                    {"name":"color"}
                ],
                "proactivelyReported":True,
                "retrievable":True
            }
        },
        
         "ColorTemperatureController": {
            "type":"AlexaInterface",
            "interface":"Alexa.ColorTemperatureController",
            "version":"3",
            "properties":{
                "supported":[
                    {"name":"colorTemperatureInKelvin"}
                ],
                "proactivelyReported":True,
                "retrievable":True
            }
        },
        
        "PowerController": {
            "type": "AlexaInterface",
            "interface": "Alexa.PowerController",
            "version": "3",
            "properties": {
                "supported": [
                    {"name": "powerState"}
                ],
                "proactivelyReported": True,
                "retrievable": True
            }
        },
                  
        "Speaker": {         
            "type":"AlexaInterface",
            "interface":"Alexa.Speaker",
            "version":"1.0",
            "properties":{  
                "supported":[  
                    { "name":"volume"},
                    { "name":"muted" }
                ],
                "proactivelyReported":True,
                "retrievable":True
            }
        },
        
        "ThermostatController": {
            "type":"AlexaInterface",
            "interface":"Alexa.ThermostatController",
            "version":"3",
            "properties":{
                "supported":[
                    {"name":"lowerSetpoint"},
                    {"name":"targetSetpoint"},
                    {"name":"upperSetpoint"},
                    {"name":"thermostatMode"}
                ],
                "proactivelyReported":True,
                "retrievable":True
            }
        },
        
        "TemperatureSensor": {
            "type":"AlexaInterface",
            "interface":"Alexa.TemperatureSensor",
            "version":"3",
            "properties":{
                "supported":[
                    {"name":"temperature"}
                ],
                "proactivelyReported":False,
                "retrievable":True
            }
        }
                
    }
    
   
    def __init__(self):
        pass

    def getControllerProperties(self, controllertype):
        
        propnames=[]
        for prop in self.interfaceTypes[controllertype]['properties']['supported']:
            propnames.append(prop['name'])
        return propnames

class adapterbase():
        
    def jsonDateHandler(self, obj):

        if hasattr(obj, 'isoformat'):
            return obj.isoformat()
        else:
            self.log.error('Found unknown object for json dump: (%s) %s' % (type(obj),obj))
            return None
 

    def loadJSON(self, jsonfilename):
        
        try:
            with open(jsonfilename,'r') as jsonfile:
                return json.loads(jsonfile.read())
        except:
            self.log.error('Error loading pattern: %s' % jsonfilename,exc_info=True)
            return {}


    def saveJSON(self, jsonfilename, data):
        
        try:
            jsonfile = open(jsonfilename, 'wt')
            json.dump(data, jsonfile, ensure_ascii=False, default=self.jsonDateHandler)
            jsonfile.close()
        except:
            self.log.error('Error saving json to %s' % jsonfilename, exc_info=True)
            
class sofabase():

    class adapterProcess():
        
        # AdapterProcess should be implemented independently by each adapter
    
        def __init__(self, log):
            pass
        
        def get(self):
            pass


    class sofaRest():
        
        # The Sofa Rest Handler provides an http request framework for retrieving the current state of an adapter

        def date_handler(self, obj):
            if hasattr(obj, 'isoformat'):
                return obj.isoformat()
            else:
                raise TypeError
                
        def lookupAddressOrName(self, item, lookup=None):
            
            if lookup==None:
                lookup=self.data
            
            result = self.dataset.getObjectFromPath("/%s" % item, data=lookup, trynames=True)
            if result!={}:
                return result
            
            if item.split('/')[0] in lookup:
                try:
                    return dpath.util.get(lookup, item)
                except:
                    self.log.error('Error with data lookup: %s' % item, exc_info=True)
                    return {}
            else:
                try:
                    nameItems=item.split('/')
                    for aitem in lookup:
                        if 'name' in lookup[aitem]:
                            if lookup[aitem]['name'].lower()==nameItems[0].lower():
                                nameItems[0]=aitem
                                newsearch="/".join(nameItems)
                                return dpath.util.get(lookup, newsearch)
                        if 'friendlyName' in lookup[aitem]:
                            if lookup[aitem]['friendlyName'].lower()==nameItems[0].lower():
                                nameItems[0]=aitem
                                newsearch="/".join(nameItems)
                                return dpath.util.get(lookup, newsearch)
                except:
                    self.log.error('Error with data request',exc_info=True)
                        
            return {}

        def queryStringAdjuster(self, querystring, lookup):
            
            if querystring.find('stateReport')>-1:
                
                self.log.info('Querystring: %s' % querystring)
                
                controllers={}
                try:
                    for cap in lookup['capabilities']:
                        if ('&' not in querystring) or (cap['interface'].split('.')[1] in querystring.split('&')):
                            props=[]
                            for item in cap['properties']['supported']:
                                props.append(item['name'])
                            controllers[cap['interface'].split('.')[1]]=props
                    self.log.info('Cont: %s' % controllers)
                    lookup=self.dataset.generateStateReport(lookup['cookie']['path'], controllers)
                    if '&' in querystring:
                        lookup=lookup['context']['properties']
                except:
                    self.log.error('Couldnt build state report for %s' % querystring, exc_info=True)

                
            elif querystring.find('keynames')>-1:
                namepairs={}
                for item in lookup:
                    try:
                        namepairs[item]=lookup[item]['name']
                    except:
                        namepairs[item]=item
                lookup=dict(namepairs)

            elif querystring.find('namekeys')>-1:
                namepairs={}
                for item in lookup:
                    try:
                        namepairs[lookup[item]['name']]=item
                    except:
                        namepairs[item]=item
                lookup=dict(namepairs)

            elif querystring.find('keys')>-1:
                lookup=list(lookup.keys())

            elif querystring.find('names')>-1:
                namepairs=[]
                for item in lookup:
                    try:
                        namepairs.append(lookup[item]['name'])
                    except:
                        namepairs.append(item)
                lookup=list(namepairs)

                
            return lookup
            
        async def rootLookupHandler(self, request):
            lookup=self.dataset.data
            if request.query_string:
                lookup=self.queryStringAdjuster(request.query_string, lookup)
            return web.Response(text=json.dumps(lookup, default=self.date_handler))


        async def deviceLookupHandler(self, request):
            lookup=self.dataset.discovery()
            #self.log.info('Devices: %s' % lookup)
            return web.Response(text=json.dumps(lookup, default=self.date_handler))
            

        async def deviceStateReportHandler(self, request):
            lookup=self.dataset.devices[urllib.parse.unquote(request.match_info['item'])].stateReport
            #self.log.info('Devices: %s' % lookup)
            return web.Response(text=json.dumps(lookup, default=self.date_handler))



        async def categoryLookupHandler(self, request):

            self.log.info('request: %s' % request.match_info['category'])
            subset=await self.dataset.getCategory(request.match_info['category'])

            if request.query_string:
                subset=self.queryStringAdjuster(request.query_string, subset)

            return web.Response(text=json.dumps(subset, default=self.date_handler))


        async def imageHandler(self, request):
            
            try:
                if hasattr(self.adapter, "virtualImage"):
                    result=await self.adapter.virtualImage(request.match_info['item'])  #controllers=self.adapter.virtualControllers(nativeObj)
                    #if str(result)[:10]=="data:image":
                    return web.Response(body=result, headers = { "Content-type": "image/jpeg" })
                        
                return web.Response(text='No image found')
            except:
                self.log.error('Error getting image for: %s' % request.match_info['item'])
                return web.Response(text='No image found')
                


        async def itemLookupHandler(self, request):
            
            subset=await self.dataset.getCategory(request.match_info['category'])
            self.log.info('Relative path: %s' % request.rel_url)
            #subset=self.lookupAddressOrName(urllib.parse.unquote(request.match_info['item']), subset)
            subset=self.dataset.getObjectFromPath("/%s" % urllib.parse.unquote(request.match_info['item']), data=subset, trynames=True)    
            if request.query_string:
                subset=self.queryStringAdjuster(request.query_string, subset)
                
            return web.Response(text=json.dumps(subset, default=self.date_handler))

        async def adapterLookupHandler(self, request):
                
            return web.Response(text=json.dumps(self.dataset.adapters, default=self.date_handler))


        async def getPathControllers(self, path):
            
            try:
                #nativeObj=dpath.util.get(self.dataset.data, path)
                #if not nativeObj:
                #    return {}
                
                if hasattr(self.adapter, "virtualControllers"):
                    #controllers=self.adapter.virtualControllers(nativeObj)
                    controllers=self.adapter.virtualControllers(path)
                    return controllers
                else:
                    self.log.warn('Adapter does not have virtualControllers')
                
                return {}
            except:
                self.log.error('Error getting path controllers: %s' % path, exc_info=True)
            

        async def rootRequestHandler(self, request):
            
            cmds=['SetBrightness', 'TurnOn', 'TurnOff', 'SetColorTemperature', 'SetColor']
            
            response={}
            if request.body_exists:
                try:
                    body=await request.read()
                    jsondata=json.loads(body.decode())
                    if 'directive' in jsondata:
                        if jsondata['directive']['header']['name']=='ReportState':
                            path="/"+"/".join(jsondata['directive']['endpoint']['endpointId'].split(":")[1:])
                            controllers=await self.getPathControllers(path)
                            response=self.dataset.generateStateReport(path, controllers, correlationToken=jsondata['directive'])
                        elif jsondata['directive']['header']['name'] in cmds:
                            self.log.info('Sending alexa command: %s %s' % (jsondata['directive']['header']['name'],jsondata))
                            response=await self.dataset.handleStateChange(jsondata)


                except:
                    self.log.error('Error handling root request: %s' % body,exc_info=True)
                    response={}

            return web.Response(text=json.dumps(response, default=self.date_handler))



        async def setHandler(self, request):
            
            if request.body_exists:
                try:
                    body=await request.read()
                    change=await self.adapter.command(urllib.parse.unquote(request.match_info['category']), urllib.parse.unquote(request.match_info['item']), json.loads(body.decode('utf-8')))
                    self.log.info('Resulting change: %s' % change)
                    #asyncio.ensure_future(self.adapter.command(urllib.parse.unquote(request.match_info['category']), urllib.parse.unquote(request.match_info['item']), json.loads(body.decode('utf-8'))))
                except:
                    self.log.error('Error transferring command: %s' % body,exc_info=True)
                    
            subset=await self.dataset.getCategory(request.match_info['category'])
            subset=self.lookupAddressOrName(urllib.parse.unquote(request.match_info['item']), subset)
            
            return web.Response(text=json.dumps(subset, default=self.date_handler))


        def __init__(self, port, loop, log=None, dataset=None):
            self.port = port
            self.loop = loop
            self.workloadData={}
            self.log=log
            self.adapter=None
            self.dataset=dataset

        def initialize(self):
            
            try:
                self.serverAddress=self.dataset.baseConfig['restAddress']
                self.serverApp = web.Application()
                self.serverApp.router.add_get('/', self.rootLookupHandler)
                self.serverApp.router.add_post('/', self.rootRequestHandler)

                self.serverApp.router.add_get('/favicon.ico', self.rootLookupHandler)
                self.serverApp.router.add_get('/adapters', self.adapterLookupHandler)
                self.serverApp.router.add_get('/discovery', self.deviceLookupHandler)
                self.serverApp.router.add_get('/discovery/{item}', self.deviceStateReportHandler)
                self.serverApp.router.add_get('/image/{item:.+}', self.imageHandler)
                self.serverApp.router.add_get('/{category}', self.categoryLookupHandler)
                #self.serverApp.router.add_get('/{category}/{item}', self.itemLookupHandler)
                self.serverApp.router.add_get('/{category}/{item:.+}', self.itemLookupHandler)


                self.serverApp.router.add_post('/{category}/{item}', self.setHandler)


                self.runner=aiohttp.web.AppRunner(self.serverApp)
                self.loop.run_until_complete(self.runner.setup())

                self.site = web.TCPSite(self.runner, self.serverAddress, self.port)
                self.loop.run_until_complete(self.site.start())
            except:
                self.log.error('Error starting REST server', exc_info=True)

        
        def shutdown(self):
            self.loop.run_until_complete(self.serverApp.shutdown())



    class sofaMQTT():

        # The Sofa MQTT Handler provides an process for pushing updates to MQTT
        
        def __init__(self, adaptername, restPort, restAddress, dataset=None):
            self.backlog=[]
            self.connected=False
            self.log = logging.getLogger('sofamqtt')
            self.log.info('MQTT Module initialized')
            self.client = MQTTClient()
            self.dataset=dataset
            self.adaptername=adaptername
            self.restPort=restPort
            self.restAddress=restAddress
            

        async def connectServer(self):
            await self.client.connect('mqtt://%s' % self.dataset.baseConfig['mqttBroker'])
            self.connected=True
            for item in self.backlog:
                self.log.info('Pushing from backlog: %s' % item)
                await self.notify(item['topic'], item['message'])


        async def topicSubscribe(self, topic="sofa"):

            try:
                await self.client.subscribe([('sofa', QOS_1),('sofa/updates', QOS_1), ('sofa/changes', QOS_1),])
                self.log.info(".. mqtt/%s now subscribed" % topic)
                await self.announceRest('sofa')
                await self.notify('sofa','{"op":"discover"}')

                while True:
                    try:
                        message = await self.client.deliver_message()
                        packet = message.publish_packet
                        #self.log.info("<< mqtt/%s %s" % (packet.variable_header.topic_name, packet.payload.data.decode()))
                        await self.processSofaMessage(packet.variable_header.topic_name, json.loads(packet.payload.data.decode()))
                    except:
                        self.log.error('Error handling MQTT inbound message', exc_info=True)
                await self.client.unsubscribe(topic)
                self.log.info(".! mqtt/%s now unsubscribed" % topic)
                await self.client.disconnect()
            except ClientException as ce:
                self.log.error("!! mqtt client exception: %s" % ce)


        async def notify(self, topic, message):
            try:
                self.log.debug(">> mqtt/%s %s" % (topic, message))
                if self.connected:
                    await self.client.publish(topic, message.encode('utf-8'), qos=0x00)
                else:
                    self.log.info('MQTT not ready to publish message, adding to backlog: %s %s' % (topic,message))
                    self.backlog.append({'topic':topic, 'message':message})
            except:
                self.log.error('Error publishing message, adding to backlog', exc_info=True)
                self.backlog.append({'topic':topic, 'message':message})

      
        async def notifyChanges(self, topic, changes):
            
            try:
                if self.connected:
                    for item in changes:
                        self.log.debug(">> mqtt/sofa/changes %s" % item)
                        item['path']="%s%s" % (self.adaptername, item['path'])
                        await self.client.publish('sofa/changes', json.dumps(item).encode('utf-8'), qos=0x00)
                else:
                    self.log.info('MQTT not ready to publish message: sofa/changes %s' % changes)

            except:
                self.log.error('Error sending sofa/changes', exc_info=True)
                


        async def announceRest(self, topic):
            
            try:
                discoveryResponse={"op":"announce", "adapter":self.adaptername, "address":self.restAddress, "port":self.restPort}
                await self.notify(topic,json.dumps(discoveryResponse))
            except:
                self.log.error('Error processing MQTT Message', exc_info=True)
            

        async def processSofaMessage(self, topic, message):
            
            try:
                if topic=="sofa/changes":
                    if message["op"]=='replace':
                        if hasattr(self.adapter, "handleSofaChanges"):
                            await self.adapter.handleSofaChanges(message)
                    
                elif 'op' in message:
                    if message['op']=='discover':
                        await self.announceRest(topic)
                    elif message['op']=='announce':
                        await self.dataset.register({message['adapter'] : { 'address':message['address'], 'port':message['port'], "url": "http://%s:%s" % (message['address'],message['port'])}})

                elif 'event' in message:
                    if message['event']['header']['name']=='StateReport':
                        if message['event']['endpoint']['endpointId'].split(":")[0]!=self.adaptername:
                        #if message['event']['endpoint']['cookie']['adapter']!=self.adaptername:
                            self.log.debug('State Report: %s' % message['event']['endpoint'])
                            if hasattr(self.adapter, "handleStateReport"):
                                await self.adapter.handleStateReport(message)

                    elif message['event']['header']['name']=='ChangeReport':
                        if message['event']['endpoint']['endpointId'].split(":")[0]!=self.adaptername:
                        #if message['event']['endpoint']['cookie']['adapter']!=self.adaptername:
                            self.log.debug('Change Report: %s' % message['event']['endpoint'])
                            if hasattr(self.adapter, "handleChangeReport"):
                                await self.adapter.handleChangeReport(message)
                                
                    else:
                        self.log.info('Message type not processed: %s' % message['event'])
 

                
            except:
                self.log.error('Error processing MQTT Message', exc_info=True)
    
    class sofaDataset():
        
        def __init__(self, log=None, adaptername="sofa", loop=None):
            self.adaptername=adaptername
            self.data=collections.defaultdict(dict)
            self.devices={}
            self.adapters={}
            self.controllers={}
            self.log=log
            self.controllerObjs=controllerObjects()
            self.commands=commandObjects()
            self.loop=loop


        def getObjectPath(self, path):
            
            try:
                return "/%s/%s" % (path.split("/")[1], path.split("/")[2])
            except IndexError:
                return None
                
            
            
        def getObjectFromPath(self, path, data=None, trynames=False):
            
            try:
                if not path:
                    return {}
                
                if not data:
                    data=self.data
                    

                for part in path.split("/")[1:]:
                    try:
                        data=data[part]
                    except (TypeError, KeyError):
                        if trynames:
                            result=None
                            for item in data:
                                try:
                                    if data[item]['name']==part:
                                        result=data[item]
                                except:
                                    pass
                                
                                try:
                                    if item['friendlyName']==part:
                                        result=item
                                except:
                                    pass
                                
                                try:
                                    if item['endpointId']==part:
                                        result=item
                                except:
                                    pass

                                try:
                                    if 'interface' in item:
                                        self.log.info('Item interface: %s' % item['interface'])
                                    if item['interface']==part:
                                        result=item['properties']['supported']
                                except:
                                    pass

                                
                                if result:
                                    self.log.info('Found match: %s %s' % (part, data))
                                    break
                                
                            if not result:
                                return {}
                            data=result
                                
                return data
            except:
                self.log.error('Error getting object from path: %s' % path, exc_info=True)
                return {}


        def discovery(self):
            
            disco=[]
            for dev in self.devices:
                disco.append(self.devices[dev].discoverResponse)
            return disco


        def addDevice(self, name, obj):
            
            try:
                self.devices[name]=obj
                self.log.info('Added %s %s (%s)' % (obj.__class__.__name__, name, obj.endpointId))
                return True
            except:
                self.log.error('Error adding device: %s %s' % (name, obj))
                return False
            

        def getDeviceByEndpointId(self, endpointId):
            
            for device in self.devices:
                if self.devices[device].endpointId==endpointId:
                    return self.devices[device]
                
            return None


        def discoveryEndpoint(self, path, interfaces, displayCategories=[], friendlyName=''):
            
            nativeObject=self.getObjectFromPath(path)
            
            if not nativeObject:
                return {}
                
            if friendlyName:
                nativeObject["name"]=friendlyName
                
            if 'name' not in nativeObject:
                nativeObject["name"]=path.rsplit("/")[0]
                
            
            endpoint={
                        "endpointId": "%s%s" % (self.adaptername, path.replace("/",":")),
                        "friendlyName": nativeObject["name"],
                        "description": "Virtual %s Device" % self.adaptername,
                        "manufacturerName": "Sofa %s" % self.adaptername,
                        "cookie": {"adapter": self.adaptername, "path": path},
                        "displayCategories": displayCategories,
                        "capabilities": [self.controllerObjs.interfaceTypes[interface] for interface in interfaces]
                    }
            
            return endpoint


        def mapProperties(self, path, interfaces):
            
            nativeObject=self.getObjectFromPath(self.getObjectPath(path))
                
            if not nativeObject:
                return {}
            
            if hasattr(self.adapter, "virtualControllerProperty"):
                proplist=[]
                for interface in interfaces:
                    props=self.controllerObjs.getControllerProperties(interface)
                    for prop in props:
                        proplist.append({"namespace": "Alexa.%s" % interface, "name": prop, "value": self.adapter.virtualControllerProperty(nativeObject, prop), "timeOfSample":datetime.datetime.utcnow().isoformat() + 'Z', "uncertaintyInMilliseconds": 1000})

            return {"properties":proplist}
                

           
        async def getCategory(self, category):
            
            if category in self.data:
                return self.data[category]
            elif hasattr(self.adapter, "virtualCategory"):
                return await self.adapter.virtualCategory(category)
            else:
                return {}

        async def register(self,adapterdata):
            
            try:
                self.oldadapters = copy.deepcopy(self.adapters)
                dpath.util.merge(self.adapters, adapterdata, flags=dpath.util.MERGE_REPLACE)
                patch = jsonpatch.JsonPatch.from_diff(self.oldadapters, self.adapters)
                if hasattr(self.adapter, "handleAdapterAnnouncement"):
                    await self.adapter.handleAdapterAnnouncement(list(patch))

            except:
                self.log.error('Error registering adapter to dataset: %s' % (adapterdata), exc_info=True)
             
            
        async def ingest(self, data, notify=True, returnChangeReport=True):
        
            try:
                # Take a copy of the existing data dictionary, use dpath to merge the updated content with the old, 
                # and then use jsonpatch to find the differences and report them.  Olddata retains the previous state
                # in case it is needed.
                self.olddata = copy.deepcopy(self.data)
                dpath.util.merge(self.data, data, flags=dpath.util.MERGE_REPLACE)
                patch = jsonpatch.JsonPatch.from_diff(self.olddata, self.data)

                if patch:
                    if notify:
                        try:
                            #asyncio.set_event_loop(self.loop)
                            #asyncio.ensure_future(self.notify(self.adaptername,patch.to_string()))
                            #asyncio.ensure_future(self.notifyChanges(self.adaptername,list(patch)))
                            
                            await self.notify(self.adaptername, patch.to_string())
                            await self.notifyChanges(self.adaptername, list(patch))
                        except:
                            self.log.error('Error in ingest-notify',exc_info=True)
                    changeReport=await self.controllerUpdates(patch)
                    if returnChangeReport:
                        return changeReport
                    else:
                        return patch

                return {}
                
            except:
                self.log.error('Error ingesting new data to dataset: %s' % data, exc_info=True)
                return {}

                
        async def controllerUpdates(self,data):
            
            try:
                updates=[]
                # Check to see if this is a new smart device that has not been added yet
                for item in data:
                    if len(item['path'].split('/'))>2: # ignore root level adds
                        newDevice=False
                        if item['op']=='add':
                            if hasattr(self.adapter, "addSmartDevice"):
                                newDevice=self.adapter.addSmartDevice(item['path'])

                        updates.append(self.updateDeviceState(item['path'], newDevice=newDevice))
                return updates
            except:
                self.log.error('Error with controllermap: %s ' % item['path'], exc_info=True)

                        
        def updateDeviceState(self, path, controllers={}, newDevice=False, correlationToken=None):

            try:
                nativeObject=self.getObjectFromPath(self.getObjectPath(path))
                smartDevice=self.getDeviceByEndpointId("%s%s" % (self.adaptername, self.getObjectPath(path).replace("/",":")))
                if not smartDevice:
                    # This device does not exist yet.  Some adapters may update out of order, and this change will be picked up
                    # when the device is created.
                    return False
                    
                if not controllers:
                    if hasattr(self.adapter, "virtualControllers"):
                        controllers=self.adapter.virtualControllers(path)

                for controller in controllers:
                    self.log.debug('Change in controller: %s %s' % (controller, controllers[controller]))
                    for prop in controllers[controller]:
                        smartController=getattr(smartDevice,controller)
                        smartProp=getattr(smartController, prop)
                        setattr(smartController, prop, self.adapter.virtualControllerProperty(nativeObject, prop))
                
                changeReport=smartDevice.changeReport(controllers.keys())
                if changeReport and not newDevice:
                    asyncio.ensure_future(self.notify('sofa/updates',json.dumps(changeReport)))
                    return changeReport
        
                elif newDevice:
                    asyncio.ensure_future(self.notify('sofa/updates',json.dumps(smartDevice.stateReport)))
                    return smartDevice.stateReport

            except:
                self.log.error('Error with update device state', exc_info=True)

                        
        def generateStateReport(self, path, controllers, correlationToken=None):
            
            try:
                nativeObject=self.getObjectFromPath(self.getObjectPath(path))

                if not nativeObject:
                    return {}

                header={"name": "StateReport", "namespace":"Alexa", "payloadVersion":"3", "messageId": str(uuid.uuid1())}
                if correlationToken:
                    header["correlationToken"]=correlationToken

                endpoint={"endpointId":"%s%s" % (self.adaptername, self.getObjectPath(path).replace("/",":")), "cookie": {"adapter": self.adaptername, "path": self.getObjectPath(path)}}
                
                try:
                    endpoint["cookie"]["name"]=nativeObject["name"]
                except:
                    pass

                proplist=[]
                self.log.debug('State Report Controllers: %s' % controllers)
                for controller in controllers:
                    for prop in controllers[controller]:
                        proplist.append({"namespace": "Alexa.%s" % controller, "name": prop, "value": self.adapter.virtualControllerProperty(nativeObject, prop), "timeOfSample":datetime.datetime.utcnow().isoformat() + 'Z', "uncertaintyInMilliseconds": 1000})


                stateReport={"event": {"header": header, "endpoint":endpoint}, "payload": {}, "context": { "properties": proplist}}
                self.log.info('State report: %s' % stateReport)         
                return stateReport
            except:
                self.log.error('Error generating state report: %s' % path, exc_info=True)
                return {}


        async def requestReportState(self, endpointId):
            try:
                dev=self.data['devices']
                adapter=endpointId.split(":")[0]
                url=self.adapters[adapter]['url']
                
                header={"name": "ReportState", "namespace":"Alexa", "payloadVersion":"3", "messageId": str(uuid.uuid1()), "correlationToken": str(uuid.uuid1())}
                endpoint={"endpointId": endpointId, "cookie": {}, "scope":{ "type":"BearerToken", "token":"access-token-from-skill" }}
                data=json.dumps({"directive": {"header": header, "endpoint": endpoint, "payload": {}}})
                headers = { "Content-type": "text/xml" }
                async with aiohttp.ClientSession() as client:
                    response=await client.post(url, data=data, headers=headers)
                    statereport=await response.read()
                    if statereport and hasattr(self.adapter, "handleStateReport"):
                        await self.adapter.handleStateReport(json.loads(statereport.decode()))
                        
                return statereport
            except:
                self.log.error("Error requesting state for %s" % endpointId,exc_info=True)
                

        async def requestStateChange(self, path, value, command=None):
            try:
                
                cmdMap={'BrightnessController':"SetBrightness",'PowerController':'TurnOn','ColorTemperatureController':"SetColorTemperature",'ColorController':'SetColor'}

                if path.split("/")[1] not in self.data['devices']:
                    self.log.warn('Could not identify endpointId for %s' % path.split("/")[1])
                    return False
                else:
                    device=self.data['devices'][path.split("/")[1]]
                    adapter=device['endpointId'].split(":")[0]
                    endpointId=device['endpointId']
                    controller=path.split("/")[2]
                    payload={ path.split("/")[3]: value}
                    
                    if not command:
                        command=cmdMap[controller]
                        # love the exceptions
                        if command=="TurnOn":
                            payload={}
                            if value==False:
                                command="TurnOff"
                            
                    url=self.adapters[adapter]['url']
                        
                    header={"name": command, "namespace":"Alexa.%s" % controller, "payloadVersion":"3", "messageId": str(uuid.uuid1()), "correlationToken": str(uuid.uuid1())}
                    endpoint={"endpointId": endpointId, "cookie": {}, "scope":{ "type":"BearerToken", "token":"access-token-from-skill" }}
                    data=json.dumps({"directive": {"header": header, "endpoint": endpoint, "payload": payload }})
                    headers = { "Content-type": "text/xml" }
                    
                    self.log.info('Sending state change request: %s' % data)
                    async with aiohttp.ClientSession() as client:
                        response=await client.post(url, data=data, headers=headers)
                        changereport=await response.read()
                        if changereport and hasattr(self.adapter, "handleChangeReport"):
                            await self.adapter.handleChangeReport(json.loads(changereport.decode()))
            except:
                self.log.error("Error requesting state for %s" % endpointId,exc_info=True)
                
        
        async def handleStateChange(self, data):
 
            device=data['directive']['endpoint']['endpointId'].split(":")[2]
            controller=data['directive']['header']['namespace'].split('.')[1]
            command=data['directive']['header']['name']
            payload=data['directive']['payload']
            
            if hasattr(self.adapter, "stateChange"):
                changeReports=await self.adapter.stateChange(device, controller, command, payload)
                for report in changeReports:
                    try:
                        if report==None:
                            self.log.info('No change report.  I blame dpath.merge for not getting deep key changes.')
                        elif report['event']['endpoint']['endpointId']==data['directive']['endpoint']['endpointId']:
                            return report
                    except:
                        self.log.info('Poorly formatted change report skipped: %s' % report, exc_info=True)
            return {}
            
            
    class sofaRequester():
        
        def __init__(self):
            pass

        async def reportStateRequest(self, path):
            
            async with aiohttp.ClientSession() as client:
                header={"name": "ReportState", "namespace":"Alexa", "payloadVersion":"3", "messageId": str(uuid.uuid1()), "correlationToken": str(uuid.uuid1())}
                endpoint={"endpointId":"%s#%s#%s" % (self.adaptername, category, item), "cookie": {"adapter": self.adaptername, "path": path}}
            
        
        async def sendRequest(self, client, source, category, item):
            restAddress='127.0.0.1'
            restPort=8081
            url = 'http://%s:%s/%s/%s' % (restAddress, restPort, category, item)
            response=await client.get(url)
            return await response.read()        
    
        async def request(self, source, category, item):
            async with aiohttp.ClientSession() as client:
                itemvalue=await self.sendRequest(client, source, category, item)
                self.data.setdefault(source, {}).setdefault(category, {})[item]=json.loads(itemvalue.decode())
                #self.data[source][category][item]=itemvalue
                return json.loads(itemvalue.decode())

            
    def logsetup(self, level="INFO"):
        loglevel=getattr(logging,level)
        logging.basicConfig(level=loglevel, format='%(asctime)-6s.%(msecs).03d %(levelname).1s %(lineno)4d %(threadName)-.1s: %(message)s',datefmt='%m/%d %H:%M:%S', filename='/opt/beta/log/%s.log' % self.adaptername,)
        self.log = logging.getLogger(self.adaptername)
        
        formatter = logging.Formatter('%(asctime)-6s.%(msecs).03d %(levelname).1s %(lineno)4d %(threadName)-.1s: %(message)s',datefmt='%m/%d %H:%M:%S')
        console = logging.StreamHandler()
        console.setFormatter(formatter)
        console.setLevel(logging.INFO)
        
        logging.getLogger(self.adaptername).addHandler(console)

        
    def readconfig(self):

        try:
            with open('/opt/beta/config/%s.json' % (self.adaptername),'r') as configfile:
                return json.loads(configfile.read())
        except:
            self.log.debug('Did not load config: %s' % self.adaptername, exc_info=True)
            return {}

    def readBaseConfig(self):

        try:
            with open('/opt/beta/config/sofabase.json','r') as configfile:
                return json.loads(configfile.read())
        except:
            self.log.debug('Did not load base config', exc_info=True)
            return {}

       

    def __init__(self, port=8081, adaptername='sofa', isAsync=False, loglevel="INFO"):
        
        self.adaptername=adaptername
        self.logsetup(loglevel)
        self.loop = asyncio.get_event_loop()
        self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=3,)
        self.restPort=port
        self.isAsync=isAsync
        
    def start(self):
        self.log.info('-- -----------------------------------------------')
        self.log.info('.. Sofa 2 Adapter module initialized and starting.')
        
        asyncio.set_event_loop(self.loop)
        
        self.dataset=self.sofaDataset(self.log, adaptername=self.adaptername, loop=self.loop)
        self.dataset.baseConfig=self.readBaseConfig()
        self.dataset.config=self.readconfig()
        
        self.requester=self.sofaRequester()
        self.requester.data=self.dataset.data
        
        self.log.info('.. starting MQTT client')
        self.restAddress=self.dataset.baseConfig['restAddress']
        self.mqttServer = self.sofaMQTT(self.adaptername, self.restPort, self.restAddress, dataset=self.dataset )

        self.dataset.notify=self.mqttServer.notify
        self.dataset.notifyChanges=self.mqttServer.notifyChanges
        
        self.log.info('.. starting REST server on port %s' % self.restPort)
        self.restServer = self.sofaRest(port=self.restPort, loop=self.loop, log=self.log, dataset=self.dataset)
        self.restServer.initialize()

        self.log.info('.. starting main adapter %s' % self.adaptername)
        self.adapter=self.adapterProcess(log=self.log, dataset=self.dataset, notify=self.mqttServer.notify, request=self.requester.request, loop=self.loop)
        self.dataset.adapter=self.adapter
        self.mqttServer.adapter=self.adapter
        self.restServer.adapter=self.adapter
    
        # wait until the adapter is created to avoid a number of race conditions
        self.loop.run_until_complete(self.mqttServer.connectServer())
        asyncio.ensure_future(self.mqttServer.topicSubscribe())

        
        if self.isAsync:
            self.loop.run_until_complete(self.adapter.start())
            #asyncio.ensure_future(self.adapter.start())
        else:
            self.workload = asyncio.ensure_future(self.loop.run_in_executor(self.executor,self.adapter.start,))
    
        self.restServer.adapter=self.adapter
        self.restServer.workloadData=self.adapter.dataset.data
        
        try:
            self.loop.run_forever()
        except KeyboardInterrupt:  # pragma: no cover
            pass
        except:
            self.log.error('Loop terminated', exc_info=True)
        finally:
            self.restServer.shutdown()
            self.executor.shutdown()
            
        self.log.info('stop')

